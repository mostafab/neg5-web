package neg5.domain.impl;

import com.google.inject.Inject;
import com.google.inject.persist.Transactional;
import java.io.Serializable;
import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.persistence.NoResultException;
import neg5.domain.api.DomainObjectApiLayer;
import neg5.domain.api.FieldValidationErrors;
import neg5.domain.impl.dataAccess.AbstractDAO;
import neg5.domain.impl.entities.AbstractDataObject;
import neg5.domain.impl.entities.Auditable;
import neg5.domain.impl.entities.CompositeIdObject;
import neg5.domain.impl.entities.IdDataObject;
import neg5.domain.impl.mappers.AbstractObjectMapper;
import neg5.userData.CurrentUserContext;
import neg5.userData.UserData;
import neg5.validation.ObjectValidationException;

public abstract class AbstractApiLayerImpl<
                EntityType extends AbstractDataObject<EntityType> & IdDataObject<IdType>,
                ApiObjectType,
                IdType extends Serializable>
        implements DomainObjectApiLayer<ApiObjectType, IdType> {

    @Inject private CurrentUserContext userContext;

    protected abstract AbstractDAO<EntityType, IdType> getDao();

    protected abstract AbstractObjectMapper<EntityType, ApiObjectType> getMapper();

    @Transactional
    @Override
    public ApiObjectType get(IdType id) {
        EntityType entity = getDao().get(id);
        if (entity == null) {
            String clazzName = getDao().getPersistentClass().getSimpleName();
            throw new NoResultException("No result found for " + clazzName + " with id " + id);
        }
        return getMapper().toDTO(entity.copyOf());
    }

    public List<ApiObjectType> get(Set<IdType> ids) {
        return ids.stream().map(id -> get(id)).collect(Collectors.toList());
    }

    @Transactional
    @Override
    public ApiObjectType create(ApiObjectType dto) {
        validateInternal(dto);
        EntityType entity = getMapper().mergeToEntity(dto);

        /* Assumption is that if the entity doesn't have a composite primary key,
        the id will be auto-generated by Hibernate.
        */
        if (!(entity instanceof CompositeIdObject)) {
            entity.setId(null);
        }
        if (entity instanceof Auditable) {
            UserData userData = userContext.getUserData().get();
            ((Auditable) entity).setAddedBy(userData.getUsername());
            ((Auditable) entity).setAddedAt(Instant.now());
        }
        EntityType createdEntity = getDao().save(entity);
        getDao().flush();
        return getMapper().toDTO(getDao().get(createdEntity.getId()));
    }

    @Transactional
    @Override
    public ApiObjectType update(ApiObjectType dto) {
        validateInternal(dto);
        updateInternal(dto);
        return get(getIdFromDTO(dto));
    }

    @Transactional
    @Override
    public void delete(IdType id) {
        getDao().delete(id);
    }

    @Transactional
    @Override
    public void delete(ApiObjectType collaborator) {
        delete(getIdFromDTO(collaborator));
    }

    @Transactional
    @Override
    public List<ApiObjectType> findAllByTournamentId(String tournamentId) {
        return getDao().findAllByTournamentId(tournamentId).stream()
                .map(entity -> getMapper().toDTO(entity))
                .collect(Collectors.toList());
    }

    protected Optional<FieldValidationErrors> validateObject(ApiObjectType dto) {
        return Optional.empty();
    }

    protected void updateInternal(ApiObjectType dto) {
        EntityType originalEntity = getDao().get(getIdFromDTO(dto));
        EntityType updated = getMapper().mergeToEntity(dto, originalEntity);
        getMapper().toDTO(getDao().save(updated).copyOf());
    }

    protected IdType getIdFromDTO(ApiObjectType dto) {
        return getMapper().mergeToEntity(dto).getId();
    }

    private void validateInternal(ApiObjectType dto) {
        Optional<FieldValidationErrors> errors = validateObject(dto);
        errors.filter(error -> !error.getErrors().isEmpty())
                .ifPresent(
                        error -> {
                            throw new ObjectValidationException(error);
                        });
    }
}
